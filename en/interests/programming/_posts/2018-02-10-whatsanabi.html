---
layout: post
title: What application binary interfaces are
excerpt: Computer programming languages are or ought to be defined in an abstract sense which lets them be implemented in different ways and detaches them from the fate of any particular system, architecture or implementation. This notwithstanding, implementations which compile the source code and translate it into machine language still face the practical questions related to this task, among which is the way in which the binaries they assemble shall be organized internally and expose their functionality to external users. Their solution to this problem is the <dfn>application binary interface</dfn>, whose different aspects are explored in this post.
date: 2018-02-10 02:15:00 +0100
tags: abi
comments: true
---
<p>C<span class="restcap">omputer programming languages</span>, insofar as the term might be employed without incurring in a dangerous simplification, are or ought to be, inasmuch as possible, defined in an abstract sense which lets them be implemented in different ways and detaches them from the fate of any particular system, architecture or implementation. C programs, for instance, may not just be assembled into an executable as with traditional toolchains, but <a rel="external" href="https://stackoverflow.com/questions/584714/is-there-an-interpreter-for-c">also interpreted</a>. This notwithstanding, implementations which compile the source code and translate it into machine language, such as GCC or Microsoft's Visual C++, still face the practical questions related to this task, among which, standing out as one of the most important, is the way in which the binaries they assemble shall be organized internally and expose their functionality to external users. Their solution to this problem &ndash;and, as it happens, the subject of the present post&ndash; is the <dfn>application binary interface</dfn>, whose different aspects will be subsequently explored.</p>
<p>The first step in doing so is narrowing down the scope of its duties. The application binary interface, commonly abbreviated as <abbr>ABI</abbr>, specifies, among other things,<span class="il"><span class="ili">the format of the produced binaries &ndash;that is, the way in which code is contained and laid out in objects, libraries and executables&ndash;</span><span class="ili">the calling convention &ndash;how function arguments are passed and return values retrieved, and, generally, how functions are called&ndash;</span><span class="ili">the size and alignment of the basic data types</span></span>, thus comprehending two different aspects: one concerning the format in which code is saved and stored, and another regarding its interaction at runtime with calling and called code.</p>
<p>Now that we have succinctly described what an <abbr>ABI</abbr> is, or reminded of it, we shall explain <em>why it is important</em>. The answer to this question, as to many others which concern themselves with some thing's importance, resides in that which it enables and makes possible, which is, in turn, that which interfaces, in general, enable and make possible: <em>communication across boundaries</em>.</p>
<p>Indeed, for symbols to be found in objects and libraries, the <abbr>ABI</abbr> after which they are formatted must be known and understood. <span class="sentsides"><span class="sentside">Otherwise, it will be impossible to retrieve the code they contain or to access it in a meaningful way, which is required not just by the toolchain when linking objects together to form an executable, but also by the operating system when loading symbols from a library at runtime</span><span class="sentside">an ubiquitous feature in modern software distributions which powers, among other things, the popular cross-language bindings, which establish a bridge between languages necessary in a time in which few libraries are natively implemented for each and every one of them</span>.</span> Linkage &ndash;whether it be static or dynamic, resolved well ahead of execution or just before it&ndash;, as well as any communication across language boundaries, is thus entirely dependent on an <abbr>ABI</abbr> being defined, agreed upon and understood.</p>
<p><span class="sentsides"><span class="sentside">Finding symbols, however, is not the end of the story: likely, functions or routines residing in external modules are to be invoked, and that should also be done according to some conventions</span><span class="sentside">those expected by the called code</span>.</span> These are the so-called <dfn>calling conventions</dfn>, which comprise the order in which arguments are to be passed, the registers used to that end, the way return values are to be offered by the callee and retrieved by the caller as well as the management of the stack before and after the call. Major implementations often support several calling conventions and even allow specifying the one to employ on a per-function basis, usually through the use of attributes and keywords<note>rSee, for example, the <a rel="external" href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html">GCC documentation on function attributes</a> and the <a rel="external" href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions">relevant Visual C++ page</a>.</note>.</p>
<p>Finally, there is a subtle, yet in no way overseeable, matter: data types and their properties, such as size and alignment, which shall be agreed upon for it to be possible to access external code at all. Indeed, types are often mere static abstractions and thus get translated in the compilation process; afterwards, code doesn't know about them, instead working with words which it expects to be of a certain size and to require a certain alignment. If the expectations of two different modules do not match, any kind of interaction between them will be impossible or, likely, result in unexpected &ndash;and potentially dangerous&ndash; behaviour.</p>
<p>As we have seen, the application binary interface plays a central role in compiling language implementations, stipulating the way in which code ought to be stored and executed. The present entry has introduced the concept; future posts might delve into the matter and offer detailed explanations of more specific topics concerning the one hereby expounded.</p>
